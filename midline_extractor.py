import numpy as np
import matplotlib
from util import utils
import util.plotting as uplt
import math


def main():
    '''Midline extraction function: creates midline of fish and centroid from input geometry

     This function takes in a segmented mask generated by detectron2 and extracts the midline as well as
     geometric center. There are some variables, found below, that are available for fine tuning to get the desired
     results. The program works in the following way:

     Step 1:    Set variables as indicated
     Step 2:    Change size of input mask to less points
     Step 3:    Compute normal vectors with the new number of points and save
     Step 4:    Change size of coords and normals to better accomodate ma point calculations
     Step 5:    Calculate internal and external ma coords and save
     Step 6:    Calculate geometric center of mass (only needs input coords, unrelated to other steps)

    Variables that MUST be set:
        outdir  directory to save everything
        save    set to True to save everything, False to not save anything
        use_ma  set to True to use the masbpy.ma utility, set to False to use ma_mp utility. For calculating internal
                points

    Variables that CAN be changed (for optimization)
        norm_neighbours     number of neighbours used when calculating normal vectors
        N                   decrease coordinate vector by 1/N

        ma_mp variables:

        ma variables:
        denoise
        denoise_delta
        denoise_absmin
        detect_planar

     Variables that SHOULD NOT be changed:
        D                   dictionary for relevant data
        D['coords']         coordinates of fish mask
        D['normals']        normal vectors of unit length, corresponding to coordinate vectors
        D['angles']         angle in radians for each normal vector, from the x-axis
        D['ma_coords_in']   internal medial axis ball points, i.e. internal midpoints
        D['ma_coords_ext']  external medial axis ball points, i.e. external symmetry line (not so relevant here)
        D['ma_q_in']        don't know!
        D['ma_q_out']       don't know!





     Functions:
        elliptic_geom_maker    creates an elliptic geometry, used for testing on simple geometry


     '''

    D = {}
    outdir = "mask_optimizer_dir/"  # "simple_example/"
    save = True  # set to True to save all calculations, set to False to not save anything
    use_ma = True
    norm_neighbours = 20
    N_normals = 80  # Original length 400
    N_ma = 15

    denoise = 30
    denoise_delta = 30
    detect_planar = 30

    denoise_absmin = 30
    denoise_min = 30

    D['coords'] = np.load(
        outdir + "original_coords.npy")  # Might need to find more robust way of loading original coords

    # Reduce number of elements and calculate normals
    D['coords_normals'] = utils.array_decimator_set_len(outdir=outdir, input_array=D['coords'], new_len=N_normals,
                                                        save_name="coords_normals", save=True)
    D['normals_normals'] = utils.compute_normals_my_func(coord=D['coords_normals'], outfile=outdir, k=norm_neighbours)

    D_k = utils.k_ma_iterator(input_coords=D['coords_normals'], input_normals=D['normals_normals'], N_ma=N_ma,
                              outdir=outdir,save=save,N_normals=N_normals)



    # Reduce number of elements even more to calculate ma-points
    #D['coords'] = utils.array_decimator_set_len(outdir=outdir, input_array=D['coords_normals'], new_len=N_ma, save_name = 'coords', save=save)
    #D['normals'] = utils.array_decimator_set_len(outdir=outdir, input_array=D['normals_normals'], new_len=N_ma,
    #                                             save_name='normals',save=save)

    #D['coords'] = utils.lin_interpol(outdir=outdir, input_vector=D['coords_normals'], new_len=40,save_name="coords.npy", save=True)
    #D['normals'] = utils.lin_interpol(outdir=outdir, input_vector=D['normals_normals'], new_len=40, save_name="normals.npy", save=True)

    #D['coords'] = utils.decimate(outdir=outdir,input_vector=D['coords_normals'], new_len=N_ma, save_name="coords", save=True)
    #D['normals'] = utils.decimate(outdir=outdir, input_vector=D['normals_normals'],new_len=N_ma, save_name="normals", save=True)

    #original_coords = np.load(outdir + "original_coords.npy")
    #k_coords, k = utils.k_decimations(input_vector=original_coords,new_len=N_ma)
    #Dk = {}
    #max_r_k = np.zeros(k)
    #Dk[0] = D
    #Dk[0]['normals'] = utils.k_decimations(input_vector=k_coords[0, :, :], new_len=N_ma)
    #Dk[0], max_r_k[0] = utils.compute_ma_my_func(Dk[0], outfile=outdir, denoise_absmin=denoise_absmin,
    #                                              denoise_delta=denoise_delta, denoise_min=denoise_min, detect_planar=detect_planar)

    #for i in range(1,k):
    #    Dk[i]['normals'] = utils.k_decimations(input_vector=k_coords[i,:,:], new_len=N_ma)
    #    Dk[i], max_r_k[i] = utils.compute_ma_my_func(Dk[i-1], outfile=outdir, denoise_absmin=denoise_absmin,
    #                                        denoise_delta=denoise_delta, denoise_min=denoise_min,
    #                                        detect_planar=detect_planar)

    # Choose one of the two compute_ma functions, either using ...ma_mp or ...ma

    # if use_ma:
    #     D, max_r = utils.compute_ma_my_func(D, outfile=outdir, denoise_absmin=denoise_absmin,
    #                                         denoise_delta=denoise_delta, denoise_min=denoise_min,
    #                                         detect_planar=detect_planar)
    # else:
    #     D, max_r = utils.compute_ma_my_func_mp(D, outfile=outdir, denoise=denoise, denoise_delta=denoise_delta,
    #                                            detect_planar=detect_planar)

    #centroid = utils.find_centroid(D['coords'], outdir=outdir)
    #D['angles'] = utils.normal_angles(D=D, outdir=outdir, save=save)

    # uplt.plot_internals(datadict=datadict)
    # uplt.externals(D)
    # uplt.all_in_one(D)

    #uplt.linearly(D,"normals")
    #uplt.linearly(D,"normals_normals")
    #uplt.print_dictionary_info(D, max_r_k[0])
    #uplt.all_in_four(D, norm_neighbours, N_ma, N_normals,centroid=centroid)

    print("Finished midline_extractor.py")


if __name__ == "__main__":
    matplotlib.use('Qt5Agg')
    main()
